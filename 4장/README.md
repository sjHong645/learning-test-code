4장 ~ 7장에서는 `코드 리팩토링`을 다룰 것이다.

## 테스트 코드와 프로덕션 코드 

지금까지 두 종류의 코드를 작성했다.

1. `프로덕션 코드` : Money, Portfolio, 관련된 동작을 포함한 돈 문제를 해결하기 위한 코드
2. `테스트 코드` : 문제를 올바르게 해결했는지 검증하는 코드. 모든 테스트 및 테스트 지원에 필요한 코드를 포함

두 종류의 코드는 서로 비슷한 점이 있다. RGR 사이클을 통해 빠르게 작성하고 저장소에 반영했다.  
하지만, `중요한 차이점`이 존재한다. 

### 단방향 의존성 

테스트하는 프로덕션 코드에 한해 `테스트 코드`는 `프로덕션 코드에 의존`해야 한다.  
하지만, 반대 방향의 의존성은 없어야 한다.

현재 모든 코드는 하나의 파일에 존재한다.  
때문에 `프로덕션 코드`에서 `테스트 코드`에 의존성이 없다고 확신할 수 없다. 그 의존성을 의도하지 않았어도 말이다. 

직접적인 의존성이 없더라도 `암시적 의존성`이 존재할 수 있다고 생각될 수 있는 대목이 있다.  
1. 코드를 작성할 때 `프로덕션 코드`에서 어떤 테스트 코드라도 실수로 사용하지 않도록 주의 깊게 살펴야 함 
2. 코드를 읽을 때 사용 패턴을 인지하고 `프로덕션 코드`는 어떤 테스트 코드도 호출할 수 없도록 누락 패턴을 신경써야 함 

`프로덕션 코드`가 `테스트 코드에 의존`할 때  
- 테스트된 코드 경로는 아주 깨끗한 상태인 반면
- 테스트되지 않은 경로는 버그에 굉장히 취약해진다. 

이렇듯 `단방향 의존성을 갖는 것`은 이러한 결함이 생기지 않도록 하기 위해서는 `필수적`이다. 

### 의존성 주입 

`의존성 주입`은 객체의 생성과 사용을 분리하는 사례다. 

이를 통해 코드의 `응집력(cohesion)을 높이`고 `커플링(coupling)을 줄인`다. 또한 의존성 주입을 통해 서로 다른 코드 유닛(클래스와 메서드)이 서로 독립적이길 요구한다.  

테스트 코드와 프로덕션 코드의 분리는 의존성 주입을 가능하게 하는 중요한 전제 조건이다. 의존성 주입에 대해서는 [11장](../11장)에서 자세히 다룰 예정이다. 

### 패키징 및 배포 

배포를 위해 애플리케이션 코드를 패키징할 때 `테스트 코드`는 거의 항상 `프로덕션 코드`와 `분리되어 패키징`된다.  
이는 `프로덕션 코드`와 `테스트 코드`가 독립적으로 배포되게 한다. 

- `프로덕션 코드`와 `테스트 코드`가 배포되는 과정
```
                                              (테스트 패키지)
개발자 ⇒ 버전 관리 시스템(ex. Git) ⇒ 빌드 서버      ⇒       비 프로덕션 환경    ⇒   프로덕션 환경 
                                              (프로덕션 패키지)           (프로덕션 패키지)
```

[13장](../13장)에서 지속적인 통합 파이프라인을 구축할 때, 배포를 보다 자세히 다룰 예정이다. 

## 모듈화 

첫 번째로 할 일 : `프로덕션 코드`에서 `테스트 코드를 분리`하기 

왜냐하면, `테스트 코드`가 `프로덕션 코드에 의존`하는 `단방향 의존성`이 돼야 하기 때문이다.

실제로 코드는 아래 항목에 따라 모듈화되어야 한다.

1. `테스트`와 `프로덕션 코드`는 분리된 소스 파일에 위치해야 한다. 이를 통해 각각의 코드를 독립적으로 다룰 수 있게 된다.  
2. 코드는 어떤 엔티티들이 같이 묶이는지 명백히 식별하기 위해 네임스페이스를 사용해야 한다.  
3. 가능하다면 명시적인 코드 지시문(ex. import, require)이 `하나의 모듈`이 `다른 모듈에 의존하는 관계를 가리켜`야 한다. 그러면, 의존성을 보다 명시적으로 기술할 수 있게 된다. 

## 의존성 제거 

두 번째로 할 일 : 테스트에서 의존성을 제거하기 

지금까지 2개의 곱셈 테스트를 만들었다. 두 테스트는 같은 기능을 검사하지만 차이가 있다.  
하나는 `유로`를 가지고 테스트했고 다른 하나는 `달러`를 가지고 테스트했다. 나눗셈 테스트는 1개만 했다.

여기서 두 곱셈 테스트를 계속 유지해야 할 지에 대한 의문이 생긴다. 

이러한 의사결정을 보다 객관적으로 만들기 위한 체크리스트는 다음과 같다. 

1. 테스트를 지워도 코드 커버리지는 동일한가?  
    - `라인 커버리지` : 테스트가 수행될 때 실행된 코드 라인의 개수를 나타내는 척도 
    - 이 기준을 따라 보면 곱셈 테스트 중 하나를 지워도 커버리지 손실은 없다. 

2. 테스트 중 하나가 중요한 특이 상황을 검증하는가? 
    - 예를 들면, 테스트 중 하나가 매우 큰 수를 곱해서 서로 다른 CPU 및 OS 상에서 오버플로 또는 언더플로가 발생되지 않는 것이 테스트 목적이라면 
    - 두 가지 테스트를 모두 유지하는 것이 타당하다.
    - 하지만, 작성한 두 곱셈 테스트는 그런 목적을 갖고 있지 않다. 

3. 서로 다른 테스트가 살아있는 문서로써 고유한 가치를 제공하는가? 
    - 예를 들어, 특수 기호 ($, ￦)를 통화기호로 사용한다면 이러한 이질적인 기호를 표시하는 문서로써 부가적인 가치가 있다고 할 수 있다.
    - 하지만, 작성한 코드는 영어 알파벳(USD, EUR, KRW)에서 추출한 문자를 사용하기 때문에 통화 간 차이는 최소한의 문서 가치를 제공한다. 

